First Week
DAY-1----2016.11.14----JS简介
1. JavaScript
		作用：页面交互，修改CSS样式；与服务器通信
		组成：ECMAScript(5.1)---JavaScript核心标准，定义并实现了JavaScript基本语法，数据类型，类型转换，内置对象，方法的基本标准
				DOM(文档对象模型)---操作页面的方法，根据ECMAScript扩展出来的操作页面的标准，提供创建、删除、修改、插入等操作页面的方法和标准，赋予操作页面的权利
				BOM(浏览器对象模型)----浏览器的相关方法，提供浏览器相关的方法和标准，比如打开/关闭窗口，地址栏
2. JavaScript代码（部分）
		onclick---鼠标点击事件
		alert("函数或方法执行")----调用浏览器默认弹窗，可以暂停代码运行
		confirm('提示文字')----类似alert，多一个取消的选项，当点确定时返回true，点取消时返回false
		prompt('提示文字')----类似alert，多出一个取消选项和一个输入框，点确定返回输入框内的内容，点取消返回false
		console.log()----调用浏览器控制台，只能获取并操作行间的CSS样式，功能类似alert，但不暂停代码运行
		onmouseover----鼠标移入事件
		onmouseout----鼠标移出事件
		onchange----表单内容发生改变后触发的事件
3. JavaScript样式
		行间JS：优点：直接；缺点：不符合W3C规则，不方便修改、维护、扩展、复用
		内部JS：推荐写在文档最后、</body>标签之前；因为浏览器的解析是自上至下的，放在<head></head>中会因页面没有加载完成而无法获取到相应的元素，解决：在<scrpt></script>最开始添加声明window.onload = fuction(){}，将所有的JS写在其内部，作用是声明页面加载完成事件；语法：<script></script>；优点：方便同一页面元素的复用
		外部JS：语法：<script src=""></script>；推荐写在文档最后、</body>标签之前；因为浏览器的解析是自上至下的，放在<head></head>中会因页面没有加载完成而无法获取到相应的元素；优点：可以被任意页面引用
4. JavaScript注释
		单行注释：//JS代码;或<!--JS代码;
		多行注释：/*JS代码;
								JS代码;*/
5. JavaScript语法：document.元素.JS样式{document.元素.style.CSS样式='属性值';}，CSS属性值中除纯数字的以外其余均需添加''
6. 变量：用var声明----变量初始化：var 变量名 = 变量数据;
		 	 作用：简化代码，储存数据，方便复用一行数据
		 	 命名规范：1)可以使用字母、数字、_、$，但第一个字符不允许时数字；2)不允许使用关键字和保留字（关键字与保留字见附录）；3)区分大小写；4)建议：语义化，eg：o--一个对象；a--一组元素；n--数字；str--字符串；arr--数组；fn--函数；使用小驼峰命名法：除首个单词外其他单词首字母大写
7. 获取元素方式（JS选择器）
		通过id获取元素：.getElementById('id名')----静态获取方法；只能在document下获取
		通过class获取元素：.getElementsByClassName('class名')----动态获取方法；不仅可以在document下获取，也可以在某个限制范围的元素下获取；获取到的为一组元素的集合，也叫类数组，有下标方便操作，也有长度，当这组元素中只要一个元素时，也必须用下标去操作这个元素；
		通过标签名获取元素：.getElementsByTagName('标签名')----动态获取方法；不仅可以在document下获取，也可以在某个限制范围的元素下获取；获取到的为一组元素的集合，也叫类数组，有下标方便操作，也有长度，当这组元素中只要一个元素时，也必须用下标去操作这个元素；
				动态获取时，获取到的是一组元素的类数组，当元素没有被生成时，获取到的是一个空集合；当在获取元素时添加数字下标，会强制获取当前下标的元素，当没有元素获取到的是一个空集合时，添加数字下标获取就会因没有当前元素从而报错
8. 函数---function 函数名(){}----作用：复用代码，声明一个函数，把要复用的代码放到函数里，在需要用的时候调用这个函数，里边的代码就会逐行执行
		匿名函数 function (){}
				声明：匿名函数不能直接声明，需直接写在事件后面，否则会报错；也可声明一个变量为一个函数：var 变量名 = function(){}
				调用：通过函数声明时关联的事件来调用函数；通过函数声明的变量来调用函数：变量名()
		有名函数 function 函数名(){}
				声明：直接声明：function 函数名(){}
				调用：直接调用：函数名(); ；事件调用：元素.事件 = 函数名; 注：此时函数名后不跟()，否则函数会直接调用，不会跟事件关联
9. 属性操作
		元素.style.CSS样式='属性值'----操作的是行间样式，可读可写
		元素.属性名 = '属性值';
		操作方式：通过.的方式操作，eg：console.log(变量名.style.width)，当样式名带-时，使用小驼峰命名法来写样式名，eg：console.log(变量名.style.backgroundColor); ；通过[]的方式操作，eg：console.log(变量名.style['background-color'])，当样式名以变量形式保存的时候必须用[]，eg: var h = height; box.style[h] = '400px';
10. 常用属性
		id
		class -- 在JS文件中需写成className
		style
		innerHTML----标签对中间的所有内容，包括子标签，行间属性
		innerText----标签中间的全部文字内容
		style.cssText----控制所有的行内CSS样式
DAY-2----2016.11.15
1. 连接符
		‘+’----如果两边都是数字，则进行加法运算；只要有一边是字符串，则进行字符串的拼接；如果两边有变量，则先将变量转换成存储的数据类型，在进行操作
		‘==’----表示等于判断，在编程语言中，‘=’为赋值
2. 布尔值（boolean）----只有两个值true或者false
3. if条件判断
		语法
				if (判断条件){如果判断条件为true，则执行相应操作}
				if (判断条件){如果判断条件为true，则执行相应操作}else{如果判断条件为false，则执行相应操作}
				if (判断条件1){如果判断条件1为true，则执行相应操作}else if(判断条件2){如果判断条件2为true，则执行相应操作}else{如果判断条件1和判断条件2均为false，则执行相应操作}----当判断条件1与判断条件2都满足的时候，只执行判断条件1的操作
			   		 也可以声明一个变量并赋给其一个布尔值true，将这个变量设置为判断条件并在操作结束后将这个变量赋布尔值false，使可以进入else的操作，并在else操作结束后重新赋true值，保证能够完成完整的if语句
4. 数组：var arr = [];----储存多个数据，数据与数据之间用逗号分割，数组顺序从0开始
		 	 数组第一位取值arr.[0]，数组最后一位取值arr.[arr.length-1]
		 	 arr.push();--往数组的最后添加数据
DAY-4----2016.11.17
1. 获取元素方式（JS选择器）
		通过id获取元素：.getElementById('id名')----动态获取方法；只能在document下获取
		通过class获取元素：.getElementsByClassName('class名')----动态获取方法；不仅可以在document下获取，也可以在某个限制范围的元素下获取；获取到的为一组元素的集合，也叫类数组，有下标方便操作，也有长度，当这组元素中只要一个元素时，也必须用下标去操作这个元素
		通过标签名获取元素：.getElementsByTagName('标签名')----动态获取方法；不仅可以在document下获取，也可以在某个限制范围的元素下获取；获取到的为一组元素的集合，也叫类数组，有下标方便操作，也有长度，当这组元素中只要一个元素时，也必须用下标去操作这个元素；
		通过CSS选择器获取元素
			.querySelector('选择器名')----静态获取方法；H5新标签，低版本不兼容；获取到的是一个元素，当有一组元素时，只能获取到元素里的第一个；不仅可以在document下获取，也可以在某个限制范围的元素下获取；选择器名写法与CSS样式表中相同，eg：当<ul id="list"><li></li></ul>时，获取li的方法为document.querySelector('#list li');
			.querySelectorAll('选择器名')；可以获取到一组元素中的全部；使用下标取值；
		静态获取方法：在获取元素之前添加元素，可以获取到该元素，获取元素之后添加元素，获取不到该元素
		动态获取方法：无论在获取元素之前还是获取元素之后添加元素，都可以获取到该元素
		动态获取时，获取到的是一组元素，当元素没有被生成时，获取到的是一个空集合；当在获取元素时添加数字下标，会强制获取当前下标的元素，当没有元素获取到的是一个空集合时，添加数字下标获取就会因没有当前元素从而报错
2. for循环----for(初始化变量;判断条件;变量改变){当满足循环条件时，进入循环，执行的操作}
				判断条件决定for是否执行，与执行次数；变量必须改变，否则会造成死循环
				当要操作多个元素时，采用for循环
3. 通过JS在HTML文件中生成大量代码：先声明一个变量，将生成的代码存放到该变量中，再将变量的值赋给想要添加代码的父集元素
										 eg: var str = '';
														for(var i=0;i<1000;i++){
															 str += '<div></div>';
														}
														body.innerHTML = str;
4. 取余（取模）----%：当a<b时，a%b=a；当a=n*b（n为正整数）时，a%b=0；当a>b时，a%b=a/b的余数                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
							数字'0'可以转换为布尔值false，其余数字可以转换为布尔值true
DAY-5----2016.11.18
1. for循环中的循环条件变量：变量声明最好写在for循环的条件内部，否则会因为参数作用域问题影响循环进行；for循环中添加点击事件，此时for循环中i的值是不满足循环条件的第一个值；for循环嵌套时，循环条件变量不能相同
2. this----关键字，指向性代码，指向调用this的对象
					函数内部调用：事件调用----指向调用事件函数的元素本身，eg：当在点击事件中alert(this);则this指向调用事件的元素
											  函数调用----指向window
					函数外部调用：指向window
Second Week
DAY-1----2016.11.21
1. 自定义属性：在非空对象下，可以添加自定义属性；作用：存储数据
2. 索引值：自定义属性的一种
DAY-2----2016.11.22
1. 数据类型
		简单（基本）数据类型
				字符串(String)--由n个字符组成，可以用单引号，也可以用双引号，但引号必须成对出现，eg：var str = 'Lawrence';，注：字符串也计算空格，查询字符串字符.charAt();
				数字(Number)--整数或是小数，eg：var num = 1;
				布尔值(boolean)--true or false，
				空(Null)--只有一个值：null，当声明的一个变量数据类型未知时，可以声明为空，当事件未绑定函数时，数据类型为null，eg：var a = null;
				未定义(Undefined)--当声明的变量没有赋值时，默认值为undefined
		复杂（复合）数据类型--可以由简单数据类型或复合数据类型组成
				对象(Object)--常见的有数组、键值对---eg: var j = {attr1: value1, attr2:value2}; console.log(j.attr1);--两个单独的对象永远不相等，eg:var a = []; var b = [];  a===b是false
						有顺序无意义用数组，有意义无顺序用键值对，数组有长度，键值对没有长度
						键值对遍历--for(var attr in j) {console.log(j[attr])}
				typeof 数据--检测当前值的数据类型，返回值的首字母是小写的；没有数据类型空，null返回的是object
2. 数据类型转换----JS支持将任意数据类型转换成字符串、数字和布尔值
			 方法--String(要转换的数据);；Number(要转换的数据);--如果能转化成数字就转成数字，如果不能则转成NaN(not a number)，NaN数据类型为数字；Boolean(要转换的数据);
						Number(字符串);---纯数字的字符串会转化成数字；当字符串以0开头时，会忽略掉开头的0；当前后有空格时，忽略空格；空字符串转化成0；字符串不是纯数字，包含其他字符，转成NaN；
						Number(布尔值);----true => 1；false => 0
						Number(undefined);----NaN
						Number(null);----转化成0
						Number(object);----空数组转成0；非空数组转成NaN；键值对转成NaN
						字符串转数字专门方法：parseInt/parseFloat(字符串);--纯数字的字符串会转化成数字；当字符串以0开头时，会忽略掉开头的0；当前后有空格时，忽略空格；空字符串转成NaN；字符串不是纯数字，包含其他字符，则只转换到数字结束的位置，忽略掉从第一个非数字起的后面部分；parseInt只能转化成整数，不识别小数，parseFloat可以识别小数
						转化为字符串的简易方法：空字符串+要转化的数据
						转化为布尔值--数字0、空字符串、NaN、undefined、null转化成布尔值false，其余的转化成true；
						转换成布尔值简易方法：!!数据=>true
DAY-3----2016.11.23
1. NaN与任何数据都不相等，也不等于自身
2. isNaN();----先调用Number();再判断转换成的是不是NaN，如果是NaN则返回true，如果不是NaN则返回false
3. 显式类型转化----明确调用某种方法将一种数据类型转换成另一种数据类型
	 隐式类型转换----没有明确调用数据类型转换方法，为了系统运算或拼接，系统将数据类型转化了
4. 运算符
		算术运算符(+,-,*,/,++,--,%)----n++和++n的相同点都是给n+1，不同点是n++是先进行赋值再+1，而++n则是先+1再进行赋值
		赋值运算符(=,+=,-=,*=,/=,%=)
		逻辑运算符(||,&&,!)----||--当两边有一个成立则返回true/当前面为真则返回前面，当前面为假则返回后面；&&--当两边有一个不成立则返回false/当前面为真则返回后面，当前面为假则返回前面
		关系运算符(>,<,>=,<=,==,!=,===,!==)----==仅判断两边值是否相同，===先判断两边数据类型，再判断两边的值，都相同才是相同
			 具体运算符优先级见附录
5. 三目：a?b:c--三元运算符，a为判断条件，b为判断为true的执行操作，c为判断为false的实行操作
6. while循环----eg：var count = 0;while (count < 10) {console.log(count);count++;}
7. switch判断----eg：switch(n) {case 1: // Start here if n == 1
																	// 执行代码块 #1.
															break;// Stop here
															case 2: // Start here if n == 2
																	// 执行代码块 #2.
															break; // Stop here
															case 3: // Start here if n == 3
																	// 执行代码块 #3.
															break; // Stop here
															default: // If all else fails...
																	// 执行代码块 #4.
															break; // stop here}
8. break----跳出循环，break后的代码均不执行
		 continue----跳过本次循环，可以继续后面的循环
DAY-4----2016.11.24
1. for in----用于键值对和数组的循环，遍历，迭代--for( var 控制变量名 in 数组或键值对名){}
2. 函数----用于复用代码，可以函数嵌套函数声明
				函数声明式：function 函数名 (形参) {函数执行内容}; 函数名(实参);--函数的声明和调用的顺序可以调换
				函数表达式：var fn = function() {}--必须先声明，后调用
				函数的参数：可以给函数里传入数据，让函数的执行和返回更灵活，增强函数的可用性和扩展性
						形参：函数声明时定义形参，只能在函数内部使用，相当于函数内部使用的变量，在函数调用时传入实参，给形参一一对应赋值
						实参：在函数调用时传入，一一对应赋值给形参，当没有赋值时是undefined
				arguments--参数集合，在不定参时使用，只能在函数内部使用，在传入实参时，赋值给形参，并将数据存入arguments
				return--函数返回值，默认值时undefined，可以返回任意数据类型--作用：函数执行完返回指定数据，终止函数的执行
Third Week
DAY-1----2016.11.28
1. 作用域----变量和函数起作用，可访问的区域
				全局作用域----没在函数里声明的变量和函数，全局可用
				函数(局部)作用域----在函数内部声明的变量或函数，只能在该函数里(包含子函数里)访问，函数外不能直接访问
2. 作用域链----变量和函数的查找规则--先查找函数内部；如果函数内部没有则找形参；如果形参没有则找上一级函数内部；一直向上查找直到查找全局
3. window----js内置对象
				用var去声明全局变量或函数，会在window中创建一个属性，名为变量/函数名，值为变量/函数值；
				首次给未定义变量赋值，会在window中创建全局变量，但是不推荐，容易造成全局污染；
4. delete----操作符，删除对象下属性；能删除的值返回true，不能删除的值返回false；用var声明的变量不能用delete删除
5. 预解析----js代码在执行之前，会先把var声明的变量和函数提到当前与的最前面，然后再逐行执行，解析顺序为先解析var，再解析函数，然后再按照赋值顺序进行赋值--函数内部>形参>全局
DAY-2----2016.11.29
1. 闭包----函数嵌套声明--防止全局污染
2. 自执行函数----标准--(function(形参){})(实参)，也可以写成~function(形参){}(实参)
3. getComputedStyle(元素名)----得到页面中某个元素最终显示的全部样式，对象--用于标准浏览器
		getComputedStyle(元素名).样式名----得到页面中某个元素的最终显示的某个样式，带单位的字符串
		获取某些样式时会出问题，获取复合样式时会返回全部的值
		对于非标准浏览器(IE浏览器)，使用--元素.currentStyle
DAY-4----2016.12.01---The last month of 2016, you need more hard-working, Lawrence
1. 定时器
		重复执行定时器--setInterval(函数,时间间隔);--函数为有名函数时不加()；时间间隔单位为毫秒，且在定义时不需要添加单位，最小时间间隔与浏览器与计算机性能相关，一般最小时间间隔设置要在12ms左右
				清除重复定时器--clearInterval(重复定时器);
				当定时器被关闭后，无法重新打开，如再次实现该定时器效果，必须重新开启一个新的定时器
		延时执行定时器--setTimeout(函数,延时);--函数为有名函数时不加()；时间间隔单位为毫秒，且在定义时不需要添加单位；只执行一次
				清除延时定时器--clearTimeout(延时定时器);--也可以使用clearInterval进行清除，但是不推荐
				将延时时间设置为0，也可以让定时器内的函数后执行，使用这种方法可以改变代码执行顺序
		定时器返回值为数字类型，为定时器的编号(ID)，从1开始，每添加一个定时器，不论是重复还是延时，编号都会+1，定时器关闭不会改变编号
		定时器里的this不能直接使用，如想实现this的功能，可以在定时器外面声明一个_this=this，在定时器中使用_this来代替this的功能；
DAY-5----2016.12.02
1. 运动----元素需要定位属性position:absolute;，用定时器实现；
		运动函数详见课件中move.js、move2.js、move3.js和move4.js
Fourth Week
DAY-1----2016.12.05
1. 时间对象(时间戳)----new Date();--获取到的是本地的时间，即电脑显示的时间；月份从0开始，12进制
		设置时间对象--数字，用逗号分隔(年,月,日,时,分,秒)，eg: new Date(2016,12,8,10,0,0)；字符串，用空格分隔('月--Eng 日 年 时:分:秒')，eg: new Date(Dec 10 2016 10:00:00)；对象，直接传入一个时间对象
		获取时间--年--getFullYear();  月--getMonth();  日--getDate();  周几--getDay();  时--getHours();  分--getMinutes();  秒--getSeconds();  毫秒--getMilliseconds();  距离1970.01.01 00:00:00的毫秒时间差--getTime();
		设置时间--年--setFullYear();  月--setMonth();  日--setDate();  时--setHours();  分--setMinutes();  秒--setSeconds();
		获取本月天数--月设置为下个月；日设置为0；当当前月为一月时会有问题出现
2. 赋值与赋址----当一个对象赋给一个变量时，此时赋给变量的是这个对象的地址，因此变量中值的改变会影响到对象中的值，对象中的值的改变不会影响到变量中的值；eg：var j = {a : 1, b : 2}; var j1 = j; j1.a = 3;此时j与j1中的值都为3；解决：数组通过循环每一位的方式将简单类型赋值给新的数组，对象通过for in循环每一位将简单类型赋值给新对象；
Fifth Week
DAY-1&2----2016.12.12&13
字符串方法
		string.length----字符串的长度，只能读不能写；
		string.charAt(i)----字符串第i位的字符，也可写作string[i]，只能读不能写，当没有第i位时返回空字符串；
		string.charCodeAt(i)----返回字符串第i位的unicode码，a-z对应的unicode码为97-122， A-Z对应的unicode码为65-90，0-9对应的unicode码为48-57，返回的是数字类型；
		String.fromCodeAt(unicode)----将unicode码转成对应的字符，返回值是字符串类型，这里的String不能用变量代替且S必须大写
		string.indexOf('searchValue',index)----字符串中的指定字符从左往右查找第一次出现的位置，当没找到指定字符时，返回-1，返回数字类型，index设置查找的起始位置，不写时默认从第0位开始；
		string.lastIndexOf('searchValue',index)----字符串中的指定字符从右往左查找第一次出现的位置，当没找到指定字符时，返回-1，返回数字类型，index设置查找的起始位置，不写时默认从最后一位开始；
		string.split(separate,length)----将字符串用指定分隔符分隔，放到数组中，返回数组，当没有参数时，将整个字符串放到数组中返回；当分隔符(separate)是空字符串时，字符串每个字符都是一个字符串放到数组中返回；当分隔符为字符串中不为首/尾的字符时，以该字符做分隔，且该字符消失；当分隔符为字符串中的首/尾字符时，返回的是空字符串+剩余部分的字符串；length为可选参数，表示分隔后保留的数组的长度
		string.toLowerCase()----不改变原字符串，返回值是将原字符串中的大写字母全部改成小写字母的字符串；
		string.toUpperCase()----不改变原字符串，返回值是将原字符串中的小写字母全部改成大写字母的字符串；
		string.slice(begin,end)----截取字符串中某一段字符片段；参数begin是截取的起始位置，end是截取的结束位置，当不写end时默认是截取到字符串结束位置；当不传参数时，返回整个字符串；当end有值时，截取部分不包括end的字符；当end值小于begin值时，返回空字符串；当begin为-n，且end为默认值时，截取的是从右往左的n个字符；
		string.substring(begin,end)----截取字符串中某一段字符片段；参数begin是截取的起始位置，end是截取的结束位置，当不写end时默认是字符串结束位置；当不传参数时，返回整个字符串；当end有值时，截取部分不包括end的字符；当end值小于begin值时，会将end值与begin值颠倒，然后返回对应区域的字符串；当begin为负值时，截取全部字符串；截取不到时返回空字符串；当不传参数时，返回整个字符串；
		string.substr(begin,length)----截取字符串中某一段字符片段；参数begin是截取的起始位置，length是截取的长度，当不写end时默认是字符串结束位置；当begin为-n，且length为默认值时，截取的是从右往左的n个字符；
		string.trim()----去除字符串前后的空格；
		string.concat(str1,str2...)----拼接字符串，不改变原字符串，返回的是拼接完的字符串；
        以上字符串方法均不改变原字符串；
DAY-4----2016.12.15
数学方法--调用Math方法时，内部会先调用Number()方法
		Math.ceil()----向上取整；Math.floor()----向下取整；Math.abs()----取绝对值；Math.round()----四舍五入取整；Math.random()----取随机数[0,1)；Math.PI----π，是一个值；Math.max(n1,n2,n3...)----返回括号中最大值；Math.min(n1,n2,n3...)----返回括号中最小值；Math.sqrt()----开平方；Math.pow(n1,n2)----返回n1的n2次方；
添加、删除类名---.classList.add()/.classList.remove()--新方法，兼容性上会有问题
DAY-5----2016.12.16
数组方法
		array.join(connector)----将数组用指定的连接符连接成字符串，返回字符串，当没有参数时，默认连接符为逗号','；当连接符(connector)为空字符串时，返回的是数组里的全部内容，不含连接符；
		array.length----数组长度，可读可写；注：不要用length操作数组数据；
		new Array()----创建数组的另一种方法，当只传入一个数字参数时，设置的是数组的长度；
		array.push(val1,val2....)----向数组尾部添加数据，返回的是添加完数据后数组的长度；
		array.pop()----删除数组尾部的数据，返回的是被删除的数据，返回值类型由被删除的值得数据类型决定；
		array.unshift(val1,val2....)----向数组的首部添加数据，返回的是添加完数据后数组的长度；
		array.shift()----删除数组首部的数据，返回的是被删除的数据，返回值类型由被删除的值得数据类型决定；
		array.reverse()----翻转数组中数据的顺序，返回的是翻转过后的数组；
		array.concat(val1,val2....)----将原数组与新数组进行拼接，不会改变原数组，返回的是拼接后的数组；
		array.sort()----根据规则给数组排序；当不传参数的时候，按照ASCII码大小排序，参数可以为一个函数，函数必须要写形参和返回值；会改变原数组；
				字符串大小比较会逐位比较大小，如果第一位能出结果，则返回这个结果，如果不能，则比较下一位，直到比较出结果；
				function(a,b){
                    return a-b--从小到大排列   
                    return b-a--从大到小排列
                    return Math.random()-0.5--随机排列
                }
		array.forEach(function (a,b,c) {})----遍历数组，参数a为数组里的每个值，b为当前值对应的数字下标，c为整个数组；
		array.every(function (a,b,c) {})----遍历数组，如果每个值都满足return的条件，则返回true，否则返回false，参数a为数组里的每个值，b为当前值对应的数字下标，c为整个数组；函数必须要写形参和返回值；
		array.filter(function (a,b,c) {})----遍历数组，将满足return条件的值放到数组中返回出来，不改变原数组，参数a为数组里的每个值，b为当前值对应的数字下标，c为整个数组；函数必须要写形参和返回值；
		array.map(function (a,b,c) {})---遍历数组，判断return的条件，将判断出的boolean结果放到新数组中返回，参数a为数组里的每个值，b为当前值对应的数字下标，c为整个数组；函数必须要写形参和返回值；
		array.some(function (a,b,c) {})----遍历数组，只要数组中有一个值满足return的条件，则返回true，否则返回false，参数a为数组里的每个值，b为当前值对应的数字下标，c为整个数组；函数必须要写形参和返回值；
		array.slice(begin,end)----截取数组中指定位置的数据放到新数组里返回，原数组不变；参数begin是截取的起始位置，end是截取的结束位置，当不写end时默认是截取到数组结束位置；当不传参数时，返回整个字符串；当end有值时，截取部分不包括end的字符；当begin为-n，且end为默认值时，截取的是从右往左的n个字符；当截取不到时，返回空数组；
		array.splice(begin,length,val1,val2....)----删除、添加、替换；参数begin是起始位置，length为长度，val1,val2....为要添加/替换的内容；会改变原数组；删除时需写参数begin与length；添加时需写参数begin、length（必须为0）、val1,val2...；替换时需写参数begin、length、val1,val2...；
		不会改变原数组的方法：array.concat()；array.forEach()；array.every()；array.filter()；array.map()；array.slice()；
Sixth Week
DAY-1&2----2016.12.19&20
算法
		冒泡排序--循环比较两个数的大小，大的上浮，小的下沉
        冒泡排序算法见笔记
		递归--常出现在循环次数未知时--指的是函数自己调用自己--有条件的调用：在函数内部调用自己前增加一个前提条件，当满足条件时才可以调用；有条件的结束：函数内部设定一个判断条件，当满足判断条件时，跳出函数
        快速排序--设定一个参考值，将其余值与参考值进行比较，将待比较数组拆分成[小于参考值],[参考值],[大于参考值]，逐次进行比较拆分，将待比较数组拆分成从小到大排列的n个数组，然后将这n个数组拼接起来，得到比较完的数组
        注：使用JS原生方法要比封装函数的方法执行速度更快
JSON--一种轻量级数据交换格式--JavaScript Object Notation--数据类型是字符串
	不支持undefined，内部字符串必须使用""，属性名必须用""包裹
	eg:j = '{"name":"Lawrence","age":23}'
	JSON.parse()--把JSON字符串转化为对象，这里的JSON为JSON对象；
	JSON.stringify(obj,function(key,value) {if (key =='属性名') {return 属性值} return value},格式化) --将对象转化为JSON字符串，这里的JSON为JSON对象；当对象中存在undefined或函数时，该属性被跳过；参数function为回调函数，可以实现转换完成后更改某个属性的属性值；参数格式化为[0-10]的数字；
DAY-4----2016.12.22
DOM---获取节点
		文档(document)的本质是字符串，页面在解析时，调用JS解析器，把标签解析成对象，对象下的方法有许多操作方法，方便操作页面上元素;
		核心对象为document，在window对象下面；
		JS在解析document时，会解析成DOM树(对象)，DOM树由DOM节点组成，操作的页面操作就是对节点的操作
				节点：类型共有12种，不同的节点类型操作的方法也不一样，eg:标签为元素节点，文字为文本节点，注释为注释节点；
				节点类型：ELEMENT-NODE  1;  ATTRIBUTE-NODE  2;  TEXT-NODE  3;  DATA_SECTION_NODE  4;  ENTITY_REFERENCE_NODE  5;  ENTITY_NODE  6;  PROCESSING_INSTRUCTION_NODE  7;   COMMENT-NODE(注释节点)  8;  DOCUMENT-NODE  9; DOCUMENT-TYPE-NODE  10;  DOCUMENT_FRAGMENT_NODE 	11;  NOTATION_NODE 	12;
				常用节点类型为元素节点(1)，属性节点(2)，文本节点(3)，注释节点(8)，document节点(9)
					node.nodeType--查看节点类型，返回的是该节点类型对应的数字；
					node.nodeName--查看节点名称，字符串类型，元素节点返回的是大写的标签名(字符串类型)，属性节点返回的小写的属性名(字符串类型)，文本节点返回#text(字符串类型)，注释节点返回#comment(字符串类型)，document节点返回#document(字符串类型)；
					ENode.attributes--获取到某个元素节点的属性集合；
					ENode.childNodes--标准浏览器下获取到某个元素节点下的全部第一级子节点，回车为文本节点，在非标准浏览器(IE)下获取到某个元素节点下的全部第一级元素子节点；
					ENode.children--获取到某个元素节点下的全部第一级元素子节点，非标准方法，经常使用；
					ENode.parentNode--获取到某个元素节点的上一级父节点，只能找到最近的父节点；
					ENode.previousElementSibling--获取到某个元素节点的上一个同级节点；
					ENode.nextElementSibling--获取到某个元素节点的下一个同级节点；
					ENode.firstElementChild--获取到某个元素节点下的第一个元素子节点；
					ENode.lastElementChild--获取到某个元素节点下的最后一个元素子节点；
Seventh Week
DAY-1----2016.12.26
DOM---元素节点属性
		Enode.offsetParent--找到某个元素节点的定位父节点(最近的定位属性不为static的父级节点)；当没有定位父节点时会找到body，body的定位父节点为null；
		Enode.offsetLeft--获取某个元素的左边框外到其定位父节点左边框内的距离，没有单位，只读，不能写；当没有定位父节点，自身也不是定位元素，获取到的是距离html文档的距离
			在Firefox下定位父节点有border和overflow，offsetLeft会重新计算；解决：不让border和overflow在定位父节点上同时存在
		Enode.offsetTop--获取某个元素的上边框外到其定位父节点上边框内的距离，没有单位，只读，不能写；
		Enode.clientWidth/clientHeight---获取某个元素节点的宽高+padding的值，不带单位；内联元素获取到的值为0  ；
		Enode.offsetWidth/offsetHeight--获取某个元素节点的宽高+padding+border的值，不带单位；
		Enode.getBoundingClientRect--得到的是一个对象，内容是left、top、bottom、right、width、height，不带单位；top为上边框外到可视区上边距离，bottom为下边框外到可视区上边的位置，left为左边框外到可视区左边的距离，right为右边框外到可视区左边的距离，width与height为自身width/height+padding+border
		Enode.getAttribute('属性名')--获取写在行间的原生属性或自定义属性，获取不到使用JS添加的自定义属性
		Enode.setAttribute('属性名','属性值')--设置写在行间的原生属性或自定义属性
		Enode.removeAttribute('属性名')--删除写在行间的原生属性或自定义属性
DAY-2----2016.12.27
DOM---生成、添加、删除、替换、克隆节点
		document.createElement()--只能从document下创建元素；只是创建了元素，可以去操作，但是并没有写入页面；
		Enode.appendChild(插入的节点)--在父节点的最后插入新的节点；页面中已有元素节点被插入则相当于是剪切；插入的是对象(节点)；
		Enode.insetBefore(插入的节点，被插入的节点)--在父节点的某个节点的前面插入新的节点；页面中已有元素节点被插入则相当于是剪切；被插入的节点必须属于父节点；
		Enode.removeChild(要删除的节点)--删除父节点下的要删除的节点；
		Enode.replaceChild(要替换的节点，要被替换的节点)--在父节点下，用一个新的节点替换原有的某个节点；被替换的节点必须属于父节点；如果要替换节点为已有节点，则相当于是剪切；
		Enode.cloneNode(boolean)--克隆节点；不传参数默认是false；当参数为true时，会克隆自身以及全部子节点的html、全部行间css和全部行间属性，无法克隆事件与JS添加的自定义属性，属于深度克隆；当参数为false时，只能克隆本身及行间样式与属性，不能克隆子节点；
DAY-3----2016.12.28
DOM---表格、表单操作方法
		table.tHead--找到表格中的头部；table.tHead.rows[0]--头部的第一行；table.tHead.cells[0]--头部的第一列；rows和cells也可以用于tbody和tfoot；
		table.tBodies--找到表格中的表格主体；以数字下标形式找到各个tbody；
		table.tFoot--找到表格中的尾部；
		form.name--通过表单的name属性找到对应的表单元素，使用name属性获取表单元素方法的父节点必须为form
Eighth Week
DAY-1----2017.01.03----Happy New Year!!!
BOM
		核心对象为window；
		window.open(URL,name,specs[新窗口有效],boolean);----打开新窗口，返回值为新打开窗口的window对象；注：写在全局，新窗口可能会被拦截(chrome,Firefox)；不写参数，默认在新窗口打开空白页(about:blank)；参数数据类型为字符串；参数URL为跳转地址，必须写全，不写http://会默认为本地地址；参数name为打开方式与框架名(name属性)，_blank为新窗口下打开，_self为在自身页面打开，_top为最外层框架，_parent为父级框架，参数specs为规格，只有在新窗口打开有效，规定了打开的新窗口的属性，'属性名=属性值,属性名=属性值'；
		window.close();----关闭窗口；默认为关闭当前窗口；在Firefox下，close只能关闭使用open打开的窗口；
		window.navigator;----浏览器信息对象；navigator.userAgent可以查看浏览器的信息
		window.location;----地址栏信息对象，可读可写；location.href获取到的是当前页面的绝对地址；search获取到的是页面的查询信息，[?,#),，eg:'www.baidu.com?s=hhh#page=1'获取到的查询信息为?s=hhh，字符串类型；hash获取到的是页面的锚信息，(#,+∞)，eg:'www.baidu.com?s=hhh#page=1'获取到的锚信息为page=1，不同的hash用&分隔，window.onhashchange()--当hash改变时执行；注：除hash以外的设置操作都会刷新页面；href，search设置不能放在全局，否则会无限刷新页面；
DAY-2----2017.01.04
BOM
		window.innerWidth/innerHeight----标准的获取可视区宽高的方法；移动端多用window.innerWidth/innerHeight，PC端多用Enode.clientWidth/clientHeight；
		window.onresize----当窗口尺寸改变时触发事件；
		window.onscroll----当滚动条发生运动时触发事件；
		window.pageXOffset/pageYOffset---获取滚动条移动位置的标准方法；chrome下也可以使用document.body.scrollTop来获取滚动条移动位置，其他浏览器使用document.documentElement.scrollTop来获取滚动条移动位置，这种方法在chrome可以获取到数据0，且不会改变；
		window.scrollTo(x,y)----设置x轴/y轴的滚动条移动位置；
		window.scrollHeight----如果自身内容没有超出父级范围，则值为父级的clientHeight；如果自身内容超出了父级范围，则值为父级clientHeight+超出部分的高度
DAY-4----2017.01.06
事件
		鼠标事件
				onclick--鼠标单击事件；某些可交互的元素回车也会触发单击事件；
				onmousedown--鼠标按下事件；onmouseup--鼠标抬起事件；
				onmouseover--鼠标移入事件；onmouseout--鼠标移出事件；从元素外移入会触发onmouseover，从元素内移入子元素内，会先触发onmouseout，再触发onmouseover；
				onmouseenter--鼠标移入事件；onmouseleave--鼠标移出事件；从元素内移入子元素内，不会触发onmouseleave，只有完全移出元素时，才会触发onmouseleave；
				onmousemove--鼠标移动事件；
				onmousewheel--鼠标滑轮滚动事件；Firefox下没有该事件；在Firefox下用Enode.addEventtListener('DOMMouseScroll',function () {})来调用鼠标滑轮滚动事件
				ondblclick--鼠标双击事件；触发双击事件时同时会触发两次单击事件，解决：给单击事件添加延时定时器；
		键盘事件--只有可输入的元素才有键盘事件；
				onkeydown--键盘按下事件；常用在表单元素和document下；按下不抬起会连续触发；所有按键都触发该事件；onkeyup--键盘抬起事件；所有按键都触发该事件；
				onkeypress--键盘按下事件；触发顺序onkeydown=>onkeypress=>onkeyup；按下不抬起会连续触发；功能键不触发该事件；
		焦点事件--只有可交互元素有焦点事件；页面中只能有一个焦点，最初焦点默认为document；设置焦点方法--点击；用tab键切换；调用js方法--focus();blur();
				onfocus--聚焦事件；onblur--失焦事件；
		表单事件----表单方法--submit()--不会触发onsubmit事件；reset()--会触发onreset事件；select()；
				onsubmit--提交事件；当点击submit时触发事件，这里的submit为input的type；
				onreset--重置事件；当点击reset时触发事件，这里的reset为input的type；
				onchange--内容改变事件；当失焦时，如果内容发生改变则触发事件；
				oninput--内容改变事件；内容键入时，当被输入的内容发生改变时调用；
DAY-5----2017.01.07
事件对象event--记录事件触发时的详细信息，只有事件调用函数里才能使用这个对象；不同的事件，事件对象记录的信息不同；在Firefox下event被认为是变量而不是对象；事件调用函数的第一个形参就是事件对象；在chrome与Firefox下可以拿到，在IE低版本中为undefined；
鼠标事件对象
		altKey/shiftKey/ctrlKey--当按下alt/shift/ctrl时，触发事件，其对应的对象值为true；
		clientX/clientY--鼠标事件触发时的位置距离可视区左边或上边的距离
		pageX/pageY--鼠标事件触发时的位置距离页面左边或上边的距离
		which--键值，代表的是按下的是鼠标的哪个键，左键为1，滑轮为2，右键为3；在chrome下无法触发右键点击；
Ninth Week
DAY-1----2017.01.09
键盘事件对象
		altKey/shiftKey/ctrlKey--当按下alt/shift/ctrl时，触发事件，其对应的对象值为true；
		keyCode--键值，判断按下的是键盘上的哪个键；只判断键，不区分大小写；键盘事件独有；常用键值：(a,z)==(65,90)；enter==13；space==32；direction left ==37；direction up ==38；direction right ==39；direction down ==40；
		which--键值，所有的输入设备都有；
事件源--触发该事件的源头；event.target；
事件委托--给父级绑定事件，父级内包裹的全部的子集都可以触发这个事件；
DAY-2----2017.01.10
事件绑定----将函数和元素的某个时间关联，当事件触发的时候，执行绑定的函数；
		通过on绑定的函数同一事件只能绑定一个函数；绑定多个函数会覆盖掉前面的函数；默认在冒泡阶段执行；
		事件监听--Enode.addEventListener('事件名',function,boolean)--作用：绑定事件；参数'事件名'数据类型为字符串，事件名不加on；参数boolean判断function是否在捕获阶段调用，当值为true在捕获阶段调用，为false时不在捕获阶段调用(在冒泡阶段调用)，当不传参数时，默认为false；因匿名函数各不相同，所以同一事件可以绑定多个匿名函数，而有名函数在同一事件下绑定则会覆盖；移动端只用这种方法绑定事件，用on绑定会有问题；
				事件流(事件模型)--事件触发时执行的流程；事件执行分为两个阶段--捕获阶段，冒泡阶段；
					捕获阶段--从window一直向下找到目标元素的过程；
					冒泡阶段--从目标元素一直向上找到window的过程；
					阻止冒泡--ev.cancelBubble--当值为true时，阻止全部的冒泡阶段的事件执行，只执行目标元素的事件；当值为false时，不阻止冒泡阶段事件的执行；默认值为false；
					阻止进程--ev.stopPropagation()--阻止后续进程的执行；
		解绑事件--Enode.removeEventtListener('事件名',function,boolean)--解绑必须是相同事件的相同函数且在相同阶段调用；匿名函数无法被解绑；无法解绑用on绑定的事件的函数；
阻止默认行为--先找到触发默认行为的事件和对象，然后阻止；阻止方法：1)在事件末尾添加return false，只能用于用on绑定的事件函数；2)ev.preventDefault()，on和addEventListener都可以使用；
右键菜单--oncontextmenu--当调用上下文菜单(右键菜单)时触发事件；
Tenth Week
DAY-1----2017.01.16
鼠标滑轮事件对象--IE/chrome下用onmousewhell绑定鼠标滑轮事件，Firefox下用Enode.addEventtListener('DOMMouseScroll',function () {})绑定事件
		IE/chrome下ev.whellDelta--当向上滚时为120，向下滚时为-120；Firefox下ev.detail--向上滚为-3，向下滚为3；
Twelfth Week
DAY-3----2017.02.15
Git 与 Github
	Git：版本控制工具
		版本控制工具有两种：svn--集成式--需要一台中央服务器中，所有的版本控制都需要借助这台服务器，如果没有网络则无法进行版本控制，共享范围较小，一般仅限在一个公司的范围；git--分布式--将每台计算机都作为一台服务器，版本控制不需要借助网络就能够形成版本；
	GitHub：网站，社交平台，开源项目，远程仓库
Git指令
	从GitHub上下载文件：git clone <文件地址>；
	查看状态：git status；
	查看版本号：git log；
	将文件从工作区存放入暂存区：git add <file>（单个文件）/.（批量操作文件）；
	将文件从暂存区存放入版本区：git commit -m "注释"；只有到了版本去才有版本控制
	将文件直接从工作区存放入版本区：git commit -a - m "注释"；
	查看工作区与暂存区的差别：git diff；被添加的内容为绿色，被删除的内容为红色
	查看暂存区与版本区的差别：git diff --cached；
	查看工作区与版本区的差别：git diff master；
	将文件从暂存区撤销到工作区：git reset HEAD <file>；
	将工作区的代码进行撤销(优先暂存区，如果暂存区没有差别则进行版本区)：git checkout -- <file>；
	如果修改多个文件之后，在提交版本库时有文件遗漏了，则可以通过1）把遗漏的文件存放到暂存区；2）git commit -m "注释" --amend；此时，最近一次的版本会与这次的版本合并成一个新版本，并删除最近的版本
DAY-4----2017.02.16
Git指令
	将工作区中手动删除的文件在暂存区也删除：git rm <file>；
	一次性删除工作区与暂存区的某个文件：git rm -f <file>；
	只删除暂存区，不删除工作区的文件：git rm --cached <file>；
	删除整个文件夹：git rm -rf <folder>；
	恢复单个文件(不能在暂存区内删除)：git checkout <file>；
	恢复历史版本：git reset --hard <版本号>；
	查看历史操作：git reflog；
	以当前版本为基础回滚一个版本：git reset --hard HEAD^；
	以当前版本为基础回滚n个版本：git reset --hard HEAD~n；
	查看远程仓库名称：git remote；
	查看远程仓库对应的GitHub地址：git remote -v；
	将版本库中内容上传到远程仓库：git push origin master；
	分支--使用场景：1）开发不稳定版本；2）开发生命周期较短的项目；3）多人协作开发；
		查看分支：git branch；
		新建分支：git branch <分支名>；
		切换分支：git checkout <分支名>；
		新建并切换分支：git checkout -b <分支名>；
		删除分支：git branch -d <分支名>；只能删除被合并后的分支；
		强制删除分支：git branch -D <分支名>；可以删除没有被合并的分支；
		合并分支：git merge <分支名>；将当前分支与待合并的分支进行合并；
		查看已经合并的分支：git branch --merged；
		查看还未合并的分支：git branch --no-merged；
	多人协作开发：1）在GitHub的项目中找到New Collaborator并点击；2）在输入框中输入协作者的ID并等待协作者确认；这样就可以实现多人协作开发同一个项目；
	协作开发时遇到冲突的问题---提交远程仓库被拒绝的解决方法：1）从远程仓库中拉取代码--git fetch；2）对比差异部分--git diff master origin/master；3）合并两边的代码，人为解决问题--git merge origin/master；4）人为判断并解决问题---在冲突部分删除不需要的代码；5）重新提交到远程仓库；
	当没有开发权限但也想参与别人项目时：1）fork别人的项目（这样就能将别人的项目添加到自己的GitHub中）；2）clone参与的项目并进行修改、提交；3）发送合并请求（点击导航栏中的Pull requests，然后点击create pull request，留言后再次点击create pull request，然后等待对方的确认）；
	当收到别人更改项目的通知时：1）点击opened pull request（当被发送请求时会有链接）；2）点击files changed去查看被修改的内容；3）当希望合并他人的修改时，可以点击merge pull request，然后点击confirm merge进行代码合并，此时自己的项目中就会有他人的更改；
	如果想避免每次都克隆别人更新的项目：1）删除自己fork的项目；2）重新fork别人的项目；3）使用git pull指令--取回远程仓库的变化，并与本地分支合并，重新拉取项目；
DAY-5----2017.02.17&&Thirteenth Week DAY-1----2017.02.20
正则表达式--用来操作(擅长匹配模糊范围)字符串；处理高效但可读性不高；
	标准语法：new RegExp(规则,修饰符);
	简写：/规则/
	当正则表达式在函数里需要进行传参时，必须使用标准语法；
转义符(\)--当遇到\/时要进行转义；
正则方法
	test();---检测正则是否匹配，如果正则成立返回true，否则返回false；语法：正则.test(str);
	str.match(正则);---字符串方法；将匹配到的字符放入一个数组中；当匹配一个值时，在匹配的内容不包括子项的时候，length为1但还有两个值index--匹配到该字符的位置与input--被查找的全部内容，在有子项的情况下，匹配到的数组的第一个值为匹配到的内容，第二个值为第一个子项匹配到的内容，第二个值为第二个子项匹配到的内容....之后为index与input；匹配不到返回null；
	str.search(正则||string);---字符串方法；用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子字符串的所在位置，如果匹配不到则返回-1；str.indexOf(string);也可以实现类似功能，但参数不能为正则，只能使用字符串；
	str.replace(被替换内容||正则表达式,替换内容);---用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子字符串；返回替换后的字符串；替换内容可以为一个函数：function($0,$1,$2){每次匹配成功后都会执行函数；（一般情况下：参数$0为每一次匹配到的内容，参数$1为匹配到的内容的索引值，参数$2为被匹配的内容；如果正则中有子项时：从函数的第一个参数之后就是匹配到的子项值，当参数个数=子项个数+1时，之后的参数为一般情况下的参数；）如果使用这个函数，必须要有return}；
转义字符--转义字符是拥有特殊含义的字符
	\d---一个数字；
	\D---非数字
	\w---一个数字、字母、下划线；
	\W---非字符；不是数字、字母、下划线；
	\s---空白符；
	\S---非空白符；
	\1---子项重定向；表示子项中重复出现的字符，必须配合子项()使用，第一个子项为\1，第二个子项为\2......；
	.---任意字符；如果想要匹配到真正的.则需要写成\.；
	\n---换行符；
	\b---边界符；匹配单词的边界；适用于英文和数字；
修饰符
	i---忽略大小写；
	g---执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）；
量词--匹配不确定的位置；修饰的是量词前面的内容；
	+---匹配至少一个至多无限的要求匹配内容的字符串；
	{}---匹配内容个数的范围；{X}为匹配包含X个要求匹配内容的字符串；{X,}为匹配至少X个至多至多无限的要求匹配内容的字符串；{X,Y}为匹配至少X个至多Y个的要求匹配内容的字符串；
	？---匹配任何包含零个或一个要求匹配内容的字符串；
	*---匹配至少零个至多无限的要求匹配内容的字符串；
	^---匹配任何开头为要求匹配内容的字符串；^要放到要求匹配内容的前面；
	$---匹配任何结尾为要求匹配内容的字符串；
表达式模式
	|---分隔符；
	[val]---只要包含[]内部的任意一个字符都可以被匹配到；整体代表一个字符；在[]内的内容有规律的情况下可以简写成[start-end]，是通过unicode编码来实现的；[]内的内容为或的关系；
	[^val]---被匹配的内容不包括[]内的才能匹配到；整体代表一个字符；
正则表达式的子项：正则表达式中()内的部分；
DAY-2----2017.02.21
面向对象---一种编程思想，将具有相同特征的归为一类，在类下面有不同特征的具体描写；
构造函数---一个普通函数，但是内部使用了this变量；对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上；如果为构造函数，则函数名首字母大写；
运算符new---专门运算函数的运算符；实现在函数内部创建并返回一个对象，这个对象叫做实例化对象；当函数的return值为一个对象时，则返回这个对象，否则返回实例化对象；new fn()相当于调用了一次fn函数，fn后的()只用于传参；
原型prototype---解决性能问题；Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象，这个对象的所有属性和方法，都会被构造函数的实例继承；允许向对象添加属性或方法；函数的原型只能让函数的实例化对象使用；
原型链proto---实例化对象与构造函数下的原型的桥梁，实例化对象的原型链==构造函数的原型；对象上有原型链，但是没有原型；构造函数上既有原型也有原型链；
DAY-3----2017.02.22
面向对象的三大核心---封装；继承；多态；
JS面向对象的三大核心---抽象；封装；继承；
面向对象注重的是功能；
包装对象---当简单类型去调用某个方法或者属性的时候，系统会先将这个简单类型转换成对象类型，当把调用的方法或者属性提取出来后，这个对象自动销毁，这个过程就叫做包装对象；包装对象的属性只能读不能写；
obj.hasOwnProperty(属性名)---判断某一个属性到底是本地属性，还是继承自prototype对象的属性；
obj.constructor---查看某个对象是由哪个构造函数构造出来的；极易被修改，当使用对象被赋值的情况下，constructor会被修改，这时去查看对象的构造函数是不准确的；解决方法：手动修改constructor指向；
instanceof---用于判断一个对象是否某个对象的实例；语法：对象 instanceof 实例化对象；
DAY-4----2017.02.23
面向对象的继承---拥有父类的属性与方法，同时拥有自己的属性与方法；
当函数声明的时候，系统会默认自带一些方法和属性，如prototype、call()、apply()......
call()---语法：fn.call(thisObj,arg1, arg2...) ；call方法可以改变函数体内部this的指向，将this的指向改为thisObj；如果没有提供thisObj参数，那么Global对象被用作thisObj
apply()---语法：fn.apply(thisObj,[arg1,arg2...])；apply方法可以改变函数体内部this的指向，将this的指向改为thisObj；如果第二个参数不是一个有效的数组或者不是arguments对象，则会导致一个TypeError；如果两个参数中有任意一个没有写，则thisObj指向Global且无法传任何参数；
常见继承
	拷贝继承
		属性继承--调用父类，通过call或者apply来修正this的指向来完成；
		方法继承--for in父类原型下的方法并赋值给子类的原型；
		注：在拷贝的时候会将非父类的属性和方法拷贝走，这是需要通过hasOwnProperty来判断拷贝的属性和方法是否属于父类；
	类式继承(原型继承)
		属性继承--调用父类，通过call或者apply来修正this的指向来完成；
		方法继承--通过建立一个空对象作为中介，实现父类和子类的继承；由于空对象的存在，父类方法和子类方法并不是直接赋址，而是通过子类的原型与原型链找到父类上的相应的方法；此时，子类的原型的constructor的指向会被更改，所以需要手动更改；
	对象继承
toString()---将某种数据类型转化成字符串；所有的内置对象都有toString()；使用alert系统内部会调用toString；构造函数也有toString()，这个toString()是通过原型链查找找到的Object的toString()；也可以实现进制转化的功能--num.toString(radix)；对象身上的toString可以判断数据的数据类型，Object.prototype.toSting.call(数据)可以查看所有的数据类型，而Array.prototype.toSting.call(数据)能查看除数组以外的数据类型；
	深度克隆--function extend(obj){	var toStr = Object.prototype.toString;	var o = toStr.call(obj) === '[object Array]'?[]:{};	for(var attr in obj)	{	if(typeof obj[attr] === 'object')	{o[attr] =  extend(obj[attr]);}	else{	o[attr] = obj[attr];}}		return o;}
DAY-5----2017.02.24
将类数组转化成数组
	1.Array.from(类数组)；
	2.Array.prototype.slice.call(类数组)；
	3.[].slice.call(类数组)；
组件--数据和方法的简单封装，将复用率高的模块封装起来，重复调用，从而达到快速开发的目的；
自定义事件
	映射--当绑定同一个事件多个函数的时候，相当于把每次绑定的事件push到对应事件的数组中；
	触发器--当指定的系统事件被触发时，就循环对应的事件数组，依次执行数组中的函数；
Forteenth Week
DAY-1----2017.02.27
jQuery---使用面向对象封装的JS类库；在jQuery中$()与jQuery()是等价的；
	版本
		1.xx--兼容IE低版本(没有新特性)；
		3.xx--不兼容IE低版本，包含新特性；
	选择器
		基本选择器
			id选择器--$('#id')；类选择器--$('.className')；元素选择器--$('tagName')；全选择器--$('*')；多重选择器--$('selector1,selector2...selectorN')--可以匹配()内的全部选择器；
		属性选择器
			[name|="value"]---选择属性名为name，属性值为value或value-的元素；
			[name *= value]---选择属性名为name，属性值包含value的元素；
			[name ^= value]---选择属性名为name，属性值以value开头的元素；
			[name $= value]---选择属性名为name，属性值以value结尾的元素；
			[name!=value]---选择属性名为name，属性值不为value的元素；
			$(':button')---找到所有input的type为button的元素；
			$(':checkbox')---找到所有input的type为checkbox的元素；
			$(':checked')---选中的checkbox元素；
			:even---选择index为偶数的元素，index从0开始计算；
			:odd---选择index为奇数的元素，index从0开始计算；
			:first-child---找到一组同级元素的第一个；
			:last-child---找到一组同级元素的最后一个；
			:gt(index)---找到相同类型元素中index大于某个值的元素；
			:lt(index)---找到相同类型元素中index小于某个值的元素；
			:eq(index)---找到相同类型元素中index等于某个值的元素；
	在jQuery中调用某个方法，一般参数一为获取，参数二为设置；可以用{}来进行批量设置；attr可以获取并设置行间属性；prop方法设置或返回被选元素的属性和值，prop()和attr()可能返回不同的值，如获取checkBox的checked属性时，attr获取的是checked与undefined，而prop获取的是true和false；
	$(document).ready(function(){})为页面结构加载完成后执行，也可写作$(function(){})；等同于原生JS中的document.addEventListener('DOMContentLoaded',function(){})；
	$(selector).html()等同于原生JS中的selector.innerHTML；$(selector).text()等同于原生JS中的selector.innerTEXT；
	jQuery中的循环---$(ele).each(function(索引,元素){})；
	自己模拟写jQuery
			(function(golbal,factory){
				factory(golbal);
			})(typeof window !== 'undefined'?window:this,function(golbal,noGolbal){
				var version = "3.1.1",
				jQuery = function(selector){
					//无new化操作 //既想在外面调用的时候不new,还想自己不调用自己
					return new jQuery.init(selector);
				}
				jQuery.prototype = {
					constructor:jQuery,
					css:function(){
						console.log(1)
					}
				}
				//jQuery.fn就相当于是个名字    创建这个构造函数就是个“炮灰”，为了防止递归用的
				jQuery.init = jQuery.prototype.fn = function(selector){
					
				}
				//意思jQ有的方法 jQuery.fn都有
				jQuery.init.prototype = jQuery.prototype;
				//给外面提供接口调用
				window.$ = window.jQuery = jQuery;
			});
DAY-2----2017.02.28
在严格模式下，默认全局的this是undefined，其他的this指向不变；在"use strick"后执行的全部都是在全部模式下的；
DOM对象与jQuery对象的互相转化
	DOM对象转化jQuery对象--$(DOM)就可以将一个DOM对象转化成jQuery对象；
	jQuery对象转化DOM对象---$(jQuery).get(index)就可以将一个jQuery对象转化成DOM对象；也可以写成$(jQuery)[index]；
添加类名---addClass(className)；移除类名---removeClass(className)；
index()--能够自动匹配*当前的元素在兄弟节点中的索引位置*；一般用index的时候，最好在index(精确匹配要找的元素)；
找索引对应的元素---get(num)与eq(num)；区别---get是将jQery对象转原生，这个时候就用不了jQuery的方法了（原生元素），eq拿到的是jQuery元素，可以使用jQuery方法；
siblings---以当前元素为基准，找到别的所有兄弟元素；一般使用需要在siblings(给个精确的范围)；
在jQuery中return false不止可以阻止冒泡，也可以阻止默认事件；
children()---找到某个元素下的所有子元素；find(selector)---找到某个元素下的所有指定的元素；parent()---找到某个元素的父元素；
hide()---等同于display:none；show()---等同于display:block；
closest---找到离自身最近的父级元素（*也包括自身*）；closest()一定要给他一个范围，不然会返回一个对象；
prev()---上一个兄弟节点；next()---下一个兄弟节点；first()---第一个节点；last()---最后一个节点；
append()---尾部添加；父元素.append(要插入的元素)；appendTo---尾部添加；要插入的元素.appendTo(父元素)；
字符串模板---`<div>${data}</div>`；`字符串`，可以换行，$()内填写要添加的数据；
头部添加---要添加的元素.insertAfter(添加到谁的后面)；要添加的元素.insertBefore(添加到谁的前面)；添加到谁的前面.before(要添加的元素):添加到的元素；添加到谁的后面.after(要添加的元素):添加到的元素；
DAY-3---2017.03.01---Last Month, good luck
在jQuery中，所有的事件都是用addEventListener绑定的，所以当调用事件前需要将前一次的事件使用off()解绑；
将所有匹配的元素替换成指定的元素---replaceWith；要替换的元素.replaceWith(被替换的元素)；或者是被替换的元素.replaceAll(要替换的元素)；
克隆元素---被克隆的元素.clone(boolean)；要想克隆元素上的事件，参数为true，默认为false；
设置行间自定义属性方法
	1)div.key = value；2)div.setAttrbute('key','value')；3)div.datashe.key = value；
获取宽高
	width()；height()；获取到的值不带单位，传参可以进行设置；获取到的是内容的宽高，不包括padding和border；
	innerWidth()；innerHeight()；获取到的值不带单位，传参可以进行设置，设置的值时内容+padding的值；获取到的值包括padding，不包括border；
	outerWidth()；outerHeight()；获取到的值不带单位，传参可以进行设置；获取到的值包括padding和border，如果传参时传true则获取的值也包括margin；
	offset()获取到的是元素的绝对位置，返回值是一个对象{top:x,left:x}；offset().top获取到的是当前位置到浏览器顶部的距离；offset().left获取到的是当前位置到浏览器左边界的距离；
滚动条的距离---scrollTop()与scrollLeft()；设置滚动条的距离scrollTo(x,y)；
绑定事件---on(events,[selector],[data],fn)，参数events为一个或多个用空格分隔的事件类型和可选的命名空间；参数selector为一个选择器字符串用于过滤器的触发事件的选择器元素的后代，如果选择的< null或省略，当它到达选定的元素，事件总是触发；参数data为当一个事件被触发时要传递event.data给事件处理函数；参数fn为该事件被触发时执行的函数， false值也可以做一个函数的简写，返回false，可以实现阻止submit等自带事件；在原生事件绑定的时候，如果出现事件套事件的情况，子事件又要用到父事件的变量时，那么这个变量要放到父事件的外面（可以是全局，也可以挂在某个对象上）；
事件对象---与原生中相同，但是没有cancelBubble，可以使用return false来代替；jQ给事件绑定函数二次封装了ev对象，常规的属性或者方法都能使用，如果不能使用，可以调ev.originalEvent（原生的事件对象）
DAY-4----2017.03.02
jQuery运动
	hide(time/speed)--隐藏；show(time/speed)--显示；toggle(time/speed)--显示隐藏切换；
	slideDown(time/speed)--滑动隐藏；slideUp(time/speed)--滑动显示；slideToggle(time/speed)--滑动显示隐藏切换；
	fadeOut(time/speed)--淡出；fadeIn(time/speed)--淡入；fadeToggle(time/speed)--淡入淡出切换；
	animate(运动样式,运动时间,回调函数)；每次触发一个运动，都把运动放入运动队列中，当运动结束以后，出队列；
	停止运动--stop(boolean,boolean)；第一个参数为--是否取消队列动画，当值为true时为将本次动画执行完，才执行下个动画；第二个参数--是否让当前动画立即完成；
	delay(time)---使当前队列的下次运动延迟多少时间后执行；finish()---没有运动方式，直接到达目标点；
工具方法
	$.extend(boolean,val1,val2)--将val2的值给val1，一般使用的使用不需要添加boolean，当要进行深度克隆时，参数boolean为true；
	$.each(obj,callback)--遍历，可用于例遍任何对象；回调函数拥有两个参数：第一个为对象的成员或数组的索引，第二个为对应变量或内容；如果需要退出 each 循环可使回调函数返回 false，其它返回值将被忽略；
	$.type(obj)--检测obj的数据类型；
	$.isFunction()--检测当前数据是不是函数；
	$.isNumeric()--检测当前数据是不是数字；
	$.isArray()--检测当前数据是不是数组；
	$.isEmptyObject()--检测是否是空白对象或是null；
	$.isPlainObject()--检测是否是纯粹对象，不能是空对象，也不是数组；
DAY-5----2017.03.03
ajax---异步JavaScript和XML；ajax输出数据都为字符串；是一种创建交互式网页应用的网页开发技术；优点：优化用户体验--当用户操作页面时，不刷新页面，只刷新数据；减少服务器压力；
XML--一般用来存储数据的，类似于html的展示形式，可以自定义标签，使用时要遵循一定规范；
ajax交互模型--创建ajax对象--new XMLHttpRequest；ajax.open(请求方式--get/post,请求的地址,是否异步--默认为true)---填写请求信息；ajax.send()---向后端发送请求；ajax.onload--等待服务器返回相应的数据；ajax.responseText---得到服务器返回的信息；
	请求方式get--通过url地址栏信息进行传输，不安全，且因浏览器不同，url长度也不同，所以传输数据的体积也会被限制；在ajax中使用get方式时，需要将请求的内容绑定在填写的地址上供后端进行查找；如果涉及到在IE下传输中文，需要使用encodeURI()去进行转化，防止解析出现问题；
	请求方式post--通过服务器发送的方式进行传输，相对安全，常用于用户的私人的信息和体积比较大的信息，理论上传输的数据是无限大的，但会被后端给限制；在ajax.open()中就不需要绑定具体请求内容，传输的数据要放在ajax.send()中；在send前需要添加ajax.setRequestHeader("Content-Type","application/x-www-form-urlencoded")；因为设置了请求头，在发送数据前，就已经将数据格式统一了，所以不会出现中文编码错误的问题；
Fifteenth Week
DAY-1----2017.03.06
eval()函数可计算某个字符串，并执行其中的的JavaScript代码；eval()内的内容必须为字符串；慎用，容易被注入病毒，可以实现将标准/不标准的JSON字符串转化成一个对象；等同于使用new Function('参数','字符串')，这种方法较为安全但是new内置对象的方法性能较低；注：在代码本身没错，但是报错的情况下，用括号包一下；
同步--在send发送后，需要等待服务器处理完毕（在完毕前不会执行后续的代码）；步骤--提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事；
异步--在send发送后，不需要等待服务器处理完毕（在完毕前会执行后续的代码）；步骤--请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕；
解析XML文件--可以通过ajax.responseXML来解析XML数据，并将XML数据转化成DOM结构，然后就可以使用DOM的方法操作对应数据；在IE下，不支持children，所以使用TagName来获取子元素；
IE中不支持innerHTML，其中IE7-9用text代替，10以上用textContent代替；
状态码---表示网页服务器HTTP响应状态；ajax.status可以获取到状态码，通过状态码就可以判断本次请求是否真的被服务器接受；判断的是请求是否成功；
	typical：200-207代表成功，4字头代表响应失败，请求失败；5、6字头代表服务器错误
请求步骤--对于ajax每步操作完成都有相应的数字返回，可以拿来做检测判断；使用ajax.readyState来获取返回的状态值，判断的是请求是否完成，不论成功或是失败；使用ajax.onreadystatechange可以获取到每一步返回的值(第0步获取不到)；
DAY-2---2017.03.07
序列化操作--将对象转化成字符串key=value&key=value的格式；用for in将对象{key:value,key:value}转换成数组[key=value,key=value]的格式，用Array.join('&')将数组转化成字符串key=value&key=value；
文件上传--使用的方式为post；在使用<input type="file">的时候，前端传递的数据在file这个元素下，有个属性files，第0个File里面的内容，就是选择上传的数据；上传时许江被上传的文件转化成二进制数据才能够被识别，使用new FormData方法可以将对象转化成二进制数据，通过append(key,value)的方式进项转化；ajax.upload.onprogress可以监控上传的进度，在这个的事件对象下有loaded——本次上传多少属性和total——上传总量属性；
DAY-3---2017.03.08
安全--一切上网的安全问题都给予一种协议---同源策略；
	同源策略--由Netscape提出的一个著名的安全策略；同源是指，域名，协议，端口相同；
常用协议--file：本地；http/https：超文本传输协议；ftp：文件共享协议；端口--访问服务器的接口；
跨域--不同域名，不同协议，不同端口；
解决跨域方法
	1）通过在高版本浏览器中创建XMLHttpRequest，配合后端在头部添加相应权限权限--Access-Control-Allow-Origin:'*'；*为添加全部权限；
	2）后端可以通过file_get_contents()获取到第三方的数据，通过服务器代理的方式，实现解决跨域请求的问题；因为后端文件与自身服务器同源，通过file_get_contents()让后端文件获取到第三方的数据，这时访问后端文件，就可以实现访问第三方数据实现跨域请求；
	3）iframe；4）flash；
	5）jsonp--json+padding；运行方式：通过script标签将外域中的内容尽量转成JS代码；script标签中提前写好的src为同步操作；可以通过动态创建script标签的方法实现按需加载，这种方式时异步操作；缺点：无法使用ajax数据；为get请求，存在使用get请求的缺点；
		jsonp步骤：动态创建script标签，按需请求数据；在全局创建一个函数接收数据；数据必须是函数名+数据的格式--fn(data)；
		动态添加了script标签后可以直接删除，因为创建就等同于发送了一次请求，就算删除，请求也是发送出去了（异步），并不影响数据的接收；
DAY-4---2017.03.09
ES6简单讲解
	let和const：const为常量，声明的常量是不能够被改变的，常量声明完后必须直接赋值，不支持预解析的功能，只在声明的块级作用域生效；let为变量，与var相比，不能在同一作用域下不能声明相同变量名的变量，不支持预解析的功能，只在声明的块级作用域生效，不同的块级作用域下的相同变量名的变量的值不会互相影响；
	块级作用域：被{}包裹的区域为一个块级作用域，块级作用域支持嵌套，外层作用域无法读取内层作用域的变量(使用let声明)，内层作用域可以读取外层层作用域的变量(使用let声明)，自执行函数(function(){})()在ES6中可以写成{}；
判断图片是否加载完成---只要是DOM元素就有onload事件
	let img = document.createElement('img');	img.onload = function () {图片加载成功后执行的操作};	img.onerror = function () {图片加载不成功执行的操作};
DAY-5---2017.03.10
cookie--储存在用户终端上的数据(特殊的自定义属性，可以被浏览器追踪到)；对于大多数浏览器，cookie的体积都很小，最新版的chrome/Safari貌似没有cookie的限制；每个域名都有cookie的大小限制，一般为50个左右；主要用来辨别用户身份，进行session跟踪的数据；在本地无法使用，必须在服务器环境下使用；默认情况下，生命周期为关闭浏览器之前，关闭浏览器，数据老化；可以通过expires设置cookie的生命周期；设置cookie：document.cookie = 'key = value;expires = time'；获取cookie时，是将整个域名下的全部cookie值获取出来，值与值之间用;和空格隔开；
服务器时间是以秒为单位的；JS时间是以毫秒为单位的；
Sixteenth Week
DAY-1---2017.03.13
本地存储--localStorage;在高版本浏览器中控制台-->Application-->Local Storage下查看，低版本浏览器不支持；设置：localStorage.setItem(key,value)；获取：localStorage.getItem(key)；删除：localStorage.removeItem(key)；清空：localStorage.clearItem()；只要不删除，就会一直存在；每个域名下一般有5M的存储空间，根据浏览器不同数据有变化；非IE浏览器可以支持本地访问，但IE必须要在服务器环境下才能生效；
window.addEventListener('storage',function(){})---当操作本地存储的数据时，在兄弟页面中触发，手动删除时会在当前页面触发事件，其余操作不会触发事件；必须在服务器环境下才能触发；
本地储存---sessionStorage;通过控制台-->Application-->Session Storage下查看；设置：sessionStorage.setItem(key,value)；获取：sessionStorage.getItem(key)；删除：sessionStorage.removeItem(key)；清空：sessionStorage.clearItem()；关闭浏览器后，生命周期结束；不支持storage事件；
模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这就大大提升了开发效率，良好的设计也使得代码重用变得更加容易；
artTemplate操作步骤：1.引入template.js文件--使用简介语法，或者template-native.js文件--使用原生语法；2.在页面建立一个空的容器，eg:<div id="box"></div>；3.建立一个script标签，script标签需要id，<script type="text/html" id="xx">；4.创建一个数据data={}；5.var xxx = template('xx', data);；6.$('#box').html(''+xxx);；7.在<script type="text/html" id="xx">内输入数据
	artTemplate简洁语法地址https://github.com/aui/artTemplate/wiki/syntax:simple；{{与}}符号包裹起来的语句为模板的逻辑表达式；对内容编码输出：{{content}}，不编码输出：{{#content}}，编码可以防止数据中含有HTML字符串，避免引起XSS攻击--XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中；条件表达式：{{if admin}}	<p>admin</p>	{{else if code > 0}}	<p>master</p>	{{else}}	<p>error!</p>	{{/if}}；遍历表达式：{{each list as value index}}	<li>{{index}} - {{value.user}}</li>	{{/each}}，无论数组或者对象都可以用each进行遍历，亦可以被简写为{{each list}}	<li>{{$index}} - {{$value.user}}</li>	{{/each}}，遍历数组写法：{{each list}}	<li>{{arr[$index]}}</li>	{{/each}}；
	artTemplate原生语法地址https://github.com/aui/artTemplate/wiki/syntax:native：写法与原生JS相似，需要将内容用<%%>包裹；
DAY-2---2017.03.14
MVC--全名是Model View Controller，是模型(model)--数据保存，视图(view)--用户界面，控制器(controller)--业务逻辑的缩写；三者的关系是：1.View传送指令到Controller，2.Controller完成业务逻辑后，要求Model改变状态，3.Model将新的数据发送到View，用户得到反馈；
DAY-3---2017.03.15
jQuery插件
	工具型：$.xxx()；可以通过$.extend({fnName:function(){}})来添加插件；
	功能型：$(xx).xxx()；可以通过$.fn.extend({fnName:function(){}})来添加插件；
class
	ES6通过class关键字定义了类的概念；class内有constructor方法，constructor方法内的内容就是ES5中构造函数的内容，为构造方法，constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法，一个类中必须要有constructor方法；除constructor方法以外都是类的方法，相当于ES5中挂靠在prototype下的方法；没有预加载的功能，不能先使用后定义；
HTML5的拖拽
	ondragstart事件：当拖拽元素开始被拖拽的时候触发的事件，此事件作用在被拖曳元素上；
	ondragenter事件：当拖曳元素进入目标元素的时候触发的事件，此事件作用在目标元素上；
	ondragover事件：拖拽元素在目标元素上移动的时候触发的事件，此事件作用在目标元素上；
	ondrop事件：被拖拽的元素在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上；
	ondragend事件：当拖拽完成后触发的事件，此事件作用在被拖曳元素上；
	如果要让ondrop事件生效，必须在document.ondragover内return false；
DAY-5---2017.03.17
兼容性
	querySelector和querySelectorAll可以支持IE7以上；
	getComputedStyle(obj).attr在IE9以下不兼容；低版本IE下可以使用obj.currentStyle.attr；
	cssText兼容IE低版本，注意此时在批量设置样式的时候，原有的行间样式会被覆盖掉；setAttribute(key,value)在IE8以下浏览器设置样式的时候样式可以被写入但是无法显示；
	String.trim()不兼容IE9以下的版本，可以封装正则方法替代：/^\s+|\s+$/；
	Array.forEach()不兼容IE9以下版本，可以封装方法替代；
	firstElementChild不兼容IE9以下的版本，获取的是父元素下的第一个子元素；firstChild兼容所有浏览器，在高版本浏览器中获取的是父元素下的第一个节点，而在低版本浏览器中获取的是第一个元素节点；其余特点相同的属性：lastElementChild与lastChild，previousElementSibling与previousSibling，nextElementSibling与nextSibling；
	window.innerWidth/innerHeight在IE9以下的版本不兼容，在低版本浏览器下使用document.documentElement.clientWidth/clientHeight；在PC端建议使用后者；
	window.pageXOffset/pageYOffset在IE9以下的版本不兼容；
	offsetLeft正常使用：设置宽高,定位....，从而要触发IE下的haslayout；指定的定位父级一定要有定位，自身也要有定位(父级是相对，自己是绝对定位)；清除默认样式；
	offsetHeight/clientHeight/scrollHeight正常使用：清除默认样式，设置相同的字体大小，除scrollHeight外尽量设置指定高度并添加样式overflow:hidden;
	事件对象：在高版本浏览器下事件函数的第一个参数为事件对象，低版本浏览器中事件对象(event)在全局，只要有事件触发，就会有；
	IE9一下版本不支持addEventListener，在低版本中使用attachEvent，attachEvent(event,function)只有冒泡阶段，没有捕获阶段，函数内部的this默认指向window，需用call改变this的指向，注attachEvent中的事件必须以on绑定，eg:attachEvent('onclick',function(){})；低版本浏览器中解绑事件使用detachEvent(event,function)
	ajax：在IE6中可以使用微软专门的插件var ajax = new ActiveXObjeect('Microsoft XMLHTTP');
Maybe Last Week
DAY-1---2017.03.20
ES6
	let和const：const为常量，声明的常量是不能够被改变的，常量声明完后必须直接赋值，不支持预解析的功能，只在声明的块级作用域生效；let为变量，与var相比，不能在同一作用域下不能声明相同变量名的变量，不支持预解析的功能，只在声明的块级作用域生效，不同的块级作用域下的相同变量名的变量的值不会互相影响；使用var声明的变量是挂在window下面的，而使用let声明的变量是不会自动在window下挂这个变量；
	块级作用域：被{}包裹的区域为一个块级作用域，块级作用域支持嵌套，外层作用域无法读取内层作用域的变量(使用let声明)，内层作用域可以读取外层层作用域的变量(使用let声明)，自执行函数(function(){})()在ES6中可以写成{}；
	暂时性死区：只要块级作用域内存在let命令，块级作用域内所声明的变量就“绑定”（binding）这个区域，不再受外部的影响；ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域，凡是在声明之前就使用这些变量，就会报错；在代码块内，使用let命令声明变量之前，该变量都是不可用的，这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）；
	变量的解构赋值：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构；当=两边的格式不相同时，解构不成功；解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错；
		数组解构：把数组中的某个值，对应解析，eg:let [a, b, c] = [1, 2, 3]; <=>let a = 1;let b = 2;let c = 3;如果解构不成功，变量的值就等于undefined；如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错；
		对象解构：对象的解构与数组有一个重要的不同，数组的元素是按次序排列的，变量的取值由它的位置决定，而对象的属性没有次序，变量必须与属性同名，才能取到正确的值；对象解构重命名：eg:var { foo: baz } = { foo: 'aaa', bar: 'bbb' };这时baz='aaa'，而访问foo则会报错；如果使用let或const先声明一个变量，然后用变量解构的方法赋值，必须在最外面包裹()，否则会报错，eg:let foo;({foo} = {foo: 1}); // 成功，而let foo;let {foo} = {foo: 1}; // 报错，foo重复声明；嵌套解构对象也可以使用解构的方法，但格式必须相同，解构对象的key值也必须相同；
		字符串解构：字符串可以可以进行解构赋值的，这是因为此时，字符串被转换成了一个类似数组的对象；eg:const [a, b, c, d, e] = 'hello';a=h,b=e,c=l,d=l,e=o；
		数组和对象解构的时候可以给赋予默认值，当解构时被赋予的值为undefined时，变量的取值为默认值；eg:let [foo = true] = [];此时foo=true；默认值可以引用解构赋值的其他变量，但该变量必须已经声明；
	字符串扩展：ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点；
	正则的扩展：ES6中规定当使用标准写法声明正则的时候，第一个参数，可以为字符串也可以为正则，第二个参数为修饰符；
	数值的扩展
		Math.trunc()：用于去除一个数的小数部分，返回整数部分；
		Math.sign()：方法用来判断一个数到底是正数、负数、还是零，会返回五种值：正数返回1，负数返回-1 ，0返回0，-0就返回-0，其他值返回NaN；
		Math.hypot(arguments)：方法返回所有参数的平方和的平方根；当参数为两个值时，为勾股定理；
	数组的扩展
		Array.from()：用于将类数组对象转为真正的数组；
		Array.of()：用于将一组参数，转换为数组；
		Array.find()：用于找出第一个符合条件的数组成员，它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined；find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组；可以接受第二个参数，用来绑定回调函数的this对象；
		Array.findIndex()：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1；可以接受第二个参数，用来绑定回调函数的this对象；
		Array.fill()：使用给定值，填充一个数组；可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置，包括起始位置，不包括结束位置；
	for..of：一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for...of循环遍历它的成员；在使用的时候，可以用数组实例的keys()方法，找key值，eg:for(let key of Array.keys())；也可以通过entries来遍历key，vlue，eg:for(let [key,val] of Array.entries())；注：object默认没有遍历接口，所以不能使用for of;
	对象的扩展
		Object.is(比较的左值,比较的右值)：在所有环境中，只要两个值是一样的，它们就应该相等；Object.is(NaN,NaN)返回值为true；
		Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）；第一个参数是目标对象，后面的参数都是源对象；如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性；
		Object.getPrototypeOf(实例化对象)：返回实例化对象的构造函数，如果构造函数的constructor被修改，那么一样不准确，需要手动还原constructor指向；
		Object.setPrototypeOf(object,prototype)：用来设置一个对象的prototype对象；
		__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象；
	Symbol：ES6定义了一个新的数据类型--Symbol，表示独一无二的值；凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突；
DAY-2---2017.03.21
ES6
	Generator函数：形式上，Generator 函数是一个普通函数，但是有两个特征，一是，function关键字与函数名之间有一个星号，二是，函数体内部使用yield语句，定义不同的内部状态；可以封装一个Generator函数，通过obj[Symbol.iterator] = fn;实现让对象使用for of循环；
	Map：ES6新定义的一种数据结构，类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键，也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现，如果你需要“键值对”的数据结构，Map比Object更合适；
		声明Map：var map = new Map()；
		查看Map长度：Map.size；
		添加key与value：Map.set(key,value)；
		获取value值：Map.get(key)，返回一个value值；
		查看有没有这个key：Map.has(key)；返回一个boolean；
		删除某个键值：Map.delete(key);
		清除全部键值：Map.clear()；
		遍历方法：Map.keys()：返回键名的遍历器；Map.values()：返回键值的遍历器；Map.entries()：返回所有成员的遍历器；forEach()：遍历Map的所有成员，map.forEach(function(value, key, map) {console.log("Key: %s, Value: %s", key, value);});
		将Map转化为数组：[...Map]；将数组转成Map：new Map([[true, 7], [{foo: 3}, ['abc']]])；
	Set：ES6新定义的一种数据结构类似于数组，但是成员的值都是唯一的，没有重复的值；Set是一个构造函数，可以传入一个数组初始化默认值
		声明Set：var set = new Set()；
		查看Set长度：Set.size；
		为Set的实例添加值：Set.add(value)；
		查看有没有这个key：Set.has(key)；返回一个boolean；
		删除某个键值：Set.delete(key);
		清除全部键值：Set.clear()；
	Class
		this指向问题：当将Class的实例化对象中的某个方法解构出来使用的时候，方法中this的指向会变为undefined，此时，需要将Class中的方法使用bind()进行绑定，eg:this.say = this.say.bind(this)，此时被解构的方法中的this同样会指向这个实例化对象；
		Class的继承：class 子类 extends 父类 {constructor(){super(name);}}，通过super()调用父类，要注意的是子类如果要调用this的方法，必须要写在super()语句下方，否则会报错，这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象；super()还可以做对象使用来获取父类身上的属性或者方法；
	Module：ES6新规定了Module--模块体系；模块功能主要由两个命令构成：export和import，export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能；
		export：写法一--export var firstName = 'Michael';写法二--var firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export {firstName, lastName, year};写法三--var n = 1;export {n as m};通过as关键字实现对输出变量的重命名;
		import：写法一--import {firstName} from './输出文件路径';写法二--import {firstName,lastName,year} from './输出文件路径';写法三--import { lastName as surname } from './profile';通过as关键字实现对接收变量的重命名;
		可以给emport语句设置default，这样import中接收的变量就不需要{}，eg:export default function crc32() {} // 输出		import crc32 from 'crc32'; // 输入
		浏览器无法直接解析ES6的Module，所以需要使用webpack将ES6转化成ES5来实现，步骤(使用cli，需安装node)是：1)在本地文件中生成一个package.json--npm init，在生成的package.json文件的scripts对象下添加添加"key":"webpack"方便之后的运行，key值为任意值(Eng)；2)在本地文件中安装webpack--npm install webpack -D;3)手动在本地配置一个webpack.config.js文件--const path = require('path');	module.exports = {entry:[//变量输出js文件的路径		'./src/app.js'],output:{//把编译好的文件放在当前目录下的build下，build可以为任意值	path:path.resolve(__dirname,'build'),//__dirname:当前目录下	filename: '[name].js' // 可以打包为多个文件}};4)生成build文件夹及其内部内容--npm run key(key为package.json文件中键值为webpack的键名);	5)配置webpack.config.js，添加一个module属性--module:{//编译es6的//添加loader需要用rules	rules: [{test: /\.js$/,use:['babel-loader']}]}，根据匹配文件的不同use的属性值也不同；6)在index.html中引入build文件夹下的js文件，使用cli运行npm run key，打开页面，就可以得到变量输出js文件中操作的内容；

